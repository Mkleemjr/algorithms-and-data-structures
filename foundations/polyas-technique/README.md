# Pólya's Problem Solving Technique

    ”There is no coming to consciousness without pain.” – Carl Jung

    ”There are no gains without pains.” – Benjamin Franklin

    ”Pain + Reflection = Progress” – Ray Dalio

This document is by and for Software Engineers. But the skill of solving problems in a systematic way is not specific to any single profession. To go even further, the framework presented here is useful to life outside of work.

The goal of this document is to teach a method for problem solving. More important than knowing any single programming language or framework is the ability to solve problems. Such a method must be generalized enough to be broadly applicable.

The method presented here was created by Hungarian mathematician George Pólya. His work, aimed at teaching mathematics, became successful far outside of that domain. His book "How To Solve It" has sold over a million copies and has been translated into 17 languages.

## The Four Step Process

1. First, you have to **understand the problem**.
2. After understanding, **make a plan**.
3. **Implement the plan**.
4. **Look back** on your work. How could it be better?

That's the entire process. You may be thinking, "how boring!". I thought that myself at first. But consider the alternative. What would you have thought if I presented a 20 step process with many decision flows? Trust in the boringly simple long enough and you may see it's beauty.

Some of the dangers of not having a formal process include: doing things out of order, combining steps, and skipping steps. Those mistakes often come with feelings of frustration and hopelessness. Solving problems is difficult, so use any tools you need to make it easier.

Creativity is still required. The process discussed is high level enough to offer structure and room for creativity. It's generalized to be applicable to a broad set of problems. Each unique problem is going to need you to be creative.

## Understand the Problem

**This is an often neglected step.** Emotions can cause you to start planning or implementation too early. Skipping the step of comprehension does yourself a disservice. If you solve for the wrong problem then you've foolishly wasted your time!

**Cultivate an open-mind.** This means staying open to the probability of being wrong. If you can do that then you'll feel more comfortable with changing your mind as new facts are discovered. It's natural to adopt new ways of thinking as you solve new problems.

**Ask clarifying questions.** A powerful tool we have in this phase is the ability to ask questions. You are interrogating the problem trying to uncover explicit and implicit assumptions. Here are some starter questions (some specific for Software Engineering problems):

- What is unknown?
- What is the end goal?
- What are the inputs and outputs?
- What constraints exist?
- Which conditions are easiest to solve for?
- What are the edge cases?
- How could this problem be visualized?
- Can you restate the problem in your own words?
- Is there enough information to find a solution?

**Try various visualizations.** Be creative in how you look at the problem. Explore new ways of framing it. The more angles or lenses you use the clearer the picture and intuition about it becomes.

**Break complex problems down.** A complicated problem is daunting. When you start to feel overwhelmed try breaking it down into smaller problems. By looking at a set of smaller problems you keep your momentum.

**Consider related problems.** As you solve more problems you'll recognize recurring patterns. A way of finding analogous problems is to consider which have the same unknown. Look for problems trying to solve for the same thing.

**Welcome new problems.** Do not fret when working on unfamiliar problems. Experience is the foundation of intelligence. With each example the more familiar it becomes and the quicker the solution will come. This is the "practice makes perfect" mantra observed.

## Make a Plan

**Make a first-pass solution.** The skill at choosing a solution comes with solving many problems. The priority is in getting something working as soon as possible. Then and only then does it make sense to find the optimal solution.

**Write the pseudocode.** Pseudocode is an informal high level description of your solution. By avoiding the syntax of a programming languages you can focus on solving the problem. Think about the mental steps for running through a test case.

**Use strategies as needed.** Here is a partial list of strategies available. For detailed descriptions of each, follow references linked below:

- Guess and check
- Make an orderly list
- Eliminate possibilities
- Use symmetry
- Look for a pattern
- Draw a picture
- Solve a simpler problem
- Use a model
- Consider special cases 
- Work backwards

**If stuck, step away.** At some point you may find yourself stuck. If you understand the problem and are stumped, try putting the problem aside for a while. Your subconscious may keep working on it.

## Implement the Plan

**Patience is key.** To follow a plan requires patience over anything else. Creative energies were necessary in the previous two phases, now we are on autopilot. Our minds are prone to wander and get bored. Stay focused and persist with the plan you've chosen.

**Check each step.** In implementing your plan be meticulous to avoid missing any detail. Can you walk the solution clearly? Write some test cases to ensure your solution works as intended.

**Repeat previous steps as needed.** While there is an order to these steps it may be the case where you need to repeat a step. Perhaps your plan is insufficient or your understanding of the problem is lacking. Starting the process over again may be the best decision.

## Look Back on your Work

**Reflect on what you did.** Pólya highlights the value in taking time to look back at what you have done. Consider what worked and what did not. Think of related problems that your solution could be applied to.

**Verify your solution.** In reviewing your work try to verify the solution works. Consider edge cases where it may fail. Be unsatisified with a single test case working. Be rigourous in testing.

**Think of improvements.** Consider the performance characteristics using Big O Notation. Can you think of a different way to solve the problem? Does it improve the current solution?

## References

- https://en.wikipedia.org/wiki/How_to_Solve_It
- https://en.wikipedia.org/wiki/George_P%C3%B3lya
